import { caches, styleSheet } from 'glamor'


/**** serverside stuff ****/

// the api's copied from aphrodite, with 1 key difference 
// we include *all* the css generated by the app 
// to optimize to only include generated styles on the pages 
// use renderStaticOptimized
export function renderStatic(fn) {
  let html = fn()
  if (html === undefined) {
    throw new Error('did you forget to return from renderToString?')
  }

  let rules = styleSheet.rules(), css = rules.map(r => r.cssText).join('')
  return { html, ids: caches.inserted.keys(), css, rules }
}

export function renderStaticOptimized(fn) {
  // parse out ids from html
  // reconstruct css/rules/cache to pass
  let html = fn()
  if (html === undefined) {
    throw new Error('did you forget to return from renderToString?')
  }
  let o = { html, ids: [], css: '', rules: [] }
  let regex = /css\-([a-zA-Z0-9]+)/gm
  let match, ids = {}
  while ((match = regex.exec(html)) !== null) {
    if (!ids[match[1] + '']) {
      ids[match[1] + ''] = true
    }
  }

  o.rules = styleSheet.rules().filter(x => {
    let regex = /css\-([a-zA-Z0-9]+)/gm
    let match = regex.exec(x.cssText)
    if (match && ids[match[1] + '']) {
      return true
    }
    if (!match) {
      return true
    }
    return false
  })
  o.ids = caches.inserted.keys().filter(id => !!ids[id + ''] || caches.registered.get(id).type === 'raw')
  o.css = o.rules.map(x => x.cssText).join('')

  return o
}

function toTag(ids) {  
  let idhash = ids.reduce((o, x) => (o[x + ''] = true, o), {})
  let rules = styleSheet.rules().filter(x => {
    let regex = /css\-([a-zA-Z0-9]+)/gm
    let match = regex.exec(x.cssText)
    if(match && idhash[match[1] + '']) {
      return true
    }    
    return false
  })
  return `<style>${rules.map(x => x.cssText).join('')}</style>`
}


// alternate strategy - inline
export function inline(html) {
  let regex = /\<|css\-([a-zA-Z0-9]+)/gm

  let match, lastBackIndex = 0, idBuffer = [], result = [], insed = {}

  let plain = styleSheet.rules().filter(x => !(/css\-([a-zA-Z0-9]+)/gm.exec(x.cssText)));
  (plain.length > 0) && result.push(`<style>${plain.map(x => x.cssText).join('')}</style>`)

  while((match = regex.exec(html)) !== null) {
    if(match[0] === '<') {
      idBuffer = idBuffer.filter(x => !insed[x]);
      (idBuffer.length > 0) && result.push(toTag(idBuffer))
      result.push(html.substring(lastBackIndex, match.index))
      lastBackIndex = match.index 
      idBuffer.forEach(x => insed[x] = true)      
      idBuffer = []
    }
    else {
      idBuffer.push(match[1])
    }
    
  }
  result.push(html.substring(lastBackIndex, html.length))
  return result.join('')
}

